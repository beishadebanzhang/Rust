使用Box<T>指向堆上数据:
    最简单直接的智能指针是 box，其类型是 Box<T>
    box 允许你将一个值放在堆上而不是栈上, 留在栈上的则是指向堆数据的指针
    使用 Box<T> 在堆上储存数据: --> 一个指针, 指向T, 我们总是知道指针需要多少空间
        fn main() {
            let b = Box::new(5);
            println!("b = {}", b);
        }

        enum List {
            Cons(i32, Box<List>),
            Nil,
        }
        let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
    Box<T> 类型是一个智能指针，因为它实现了 Deref trait，它允许 Box<T> 值被当作引用对待
    当 Box<T> 值离开作用域时，由于 Box<T> 类型 Drop trait 的实现，box 所指向的堆数据也会被清除
通过 Deref trait 将智能指针当作常规引用处理:
    实现 Deref trait 允许我们重载 解引用运算符（dereference operator）*
    通过这种方式实现 Deref trait 的智能指针可以被当作常规引用来对待，可以编写操作引用的代码并用于智能指针
    通过解引用运算符追踪指针的值:
        fn main() {
            let x = 5;
            let y = &x;
            assert_eq!(5, x);
            assert_eq!(5, *y); // 一旦解引用了 y，就可以访问 y 所指向的整型值并可以与 5 做比较
        }
    像引用一样使用 Box<T>:
        fn main() {
            let x = 5;
            let y = Box::new(x); // 一个指向 x 值拷贝的 box 实例，而不是指向 x 值的引用
            assert_eq!(5, x);
            assert_eq!(5, *y); // 使用解引用运算符以 y 为引用时相同的方式追踪 box 的指针
        }
    自定义智能指针:
        struct MyBox<T>(T);

        impl<T> MyBox<T> {
            fn new(x: T) -> MyBox<T> {
                MyBox(x)
            }
        }

        use std::ops::Deref;
        impl<T> Deref for MyBox<T> {
            type Target = T;

            fn deref(&self) -> &Self::Target {
                &self.0
            }
        }

        fn main() {
            let x = 5;
            let y = MyBox::new(x);

            assert_eq!(5, x);
            assert_eq!(5, *y); // *y 实际为 *(y.deref()), y.deref()返回引用而不是值的原因在于防止所有权变动
        }
    函数和方法的隐式 Deref 强制转换:
        Deref 强制转换 可以将 &String 转换为 &str，因为 String 实现了 Deref trait 因此可以返回 &str
        fn hello(name: &str) {
            println!("Hello, {}!", name);
        }
        fn main() {
            let m = MyBox::new(String::from("Rust"));
            hello(&m); // 如果Rust没有 Deref 强制转换则必须编写的代码, 则hello(&(*m)[..]);
        }
    Deref强制转换如何与可变性交互:
        Rust 在发现类型和 trait 实现满足三种情况时会进行 Deref 强制转换:
            当 T: Deref<Target=U> 时从 &T 到 &U
            当 T: DerefMut<Target=U> 时从 &mut T 到 &mut U
            当 T: Deref<Target=U> 时从 &mut T 到 &U
使用 Drop Trait 运行清理代码:
    impl Drop for CustomSmartPointer {
        fn drop(&mut self) {
            println!("Dropping CustomSmartPointer with data `{}`!", self.data);
        }
    }
    变量以被创建时相反的顺序被丢弃，所以 d 在 c 之前被丢弃
    通过 std::mem::drop 提早丢弃值:
        Rust 不允许我们显式调用 drop 因为 Rust 仍然会在 main 的结尾对值自动调用 drop
        fn main() {
            let c = CustomSmartPointer {
                data: String::from("some data"),
            };
            println!("CustomSmartPointer created.");
            drop(c); // std::mem::drop 位于 prelude
            println!("CustomSmartPointer dropped before the end of main.");
        }
Rc<T> 引用计数智能指针:
    使用 Rc<T> 共享数据:
        enum List {
            Cons(i32, Rc<List>),
            Nil,
        }

        use crate::List::{Cons, Nil};
        use std::rc::Rc;

        fn main() {
            let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
            let b = Cons(3, Rc::clone(&a)); // 或者使用a.clone();
            let c = Cons(4, Rc::clone(&a));
        }
    克隆 Rc<T> 会增加引用计数:
        Rc::strong_count(&a); // 获取引用计数, Drop trait 的实现当 Rc<T> 值离开作用域时自动减少引用计数
// todo RefCell<T> 和内部可变性模式:
    通过 RefCell<T> 在运行时检查借用规则:
        Rc<T> 允许相同数据有多个所有者；Box<T> 和 RefCell<T> 有单一所有者
        Box<T> 允许在编译时执行不可变或可变借用检查；Rc<T>仅允许在编译时执行不可变借用检查；RefCell<T> 允许在运行时执行不可变或可变借用检查
        因为 RefCell<T> 允许在运行时执行可变借用检查，所以我们可以在即便 RefCell<T> 自身是不可变的情况下修改其内部的值
    内部可变性：不可变值的可变借用:
引用循环会导致内存泄露:

